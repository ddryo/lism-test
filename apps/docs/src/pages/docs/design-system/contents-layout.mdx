import { Container, Box, Text, Center, Columns, Layer } from '@loos/lism-core';
import { Desktop } from "@phosphor-icons/react";

# コンテンツレイアウト


Lismでサイト構築するにあたり、コンテンツのレイアウトを行うために必要な前提知識がいくつかあります。
このページでは、それらの紹介をしていきます。

<Alert icon={Desktop} keycolor='purple'>
このページはPCでの閲覧を推奨しています。
</Alert>

## Layout State クラス

コンテンツの横幅や左右の統一された余白をつけたり、コンテンツ間隔を調整するための Layout State クラスを用意しています。

- `is--container` : コンテナ要素で、かつ**自身の横幅**を制御できるクラス
- `is--constrained` : コンテナ要素で、かつ**子要素の横幅**を制御するためのクラス
	{/* - （WordPressでいうところの`is-layout-constrained`の機能にあたります。） */}
- `is--flow` : コンテンツ間隔の余白量を制御するためのクラス
	{/* - （WordPressでいうところの`is-layout-flow`と同じ役割です。） */}
- `has--gutter` : サイトを通してコンテンツの左右に統一された余白をつけるためのクラス
	{/* - （WordPressでいうところの`has-global-padding`と同じ役割です。） */}
- <MemoBadge>クラス名要検討</MemoBadge>
	- `alignfull` : 全幅コンテンツ（親要素基準）を作るためのクラス。（is--fullwide?)
	- `alignwide` : 幅広コンテンツを作るためのクラス（is--wide?)
	- `alignscreen` : 全幅コンテンツ（ウィンドウ幅）を作るためのクラス (is--screenwide?)  <MemoBadge>@property対応ブラウザのみ</MemoBadge>
{/* - alignleft,alignright, aligncenter : 左右に寄せるためのクラス */}


WordPressを意識した設計になっています。

`<Layout>`系列コンポーネントでは、`isConstrained`や`isFlow`,`hasGutter`など対応するpropを指定できるようになっています。


## コンテナクエリ採用

主要なCSSプロパティに対してブレイクポイント指定が簡単にできるようになっているのがLismの特徴の一つですが、これらはコンテナクエリを採用しています。
（メディアクエリ版のCSSファイルも用意するかは検討中）

## コンテンツサイズの制御に関する推奨手法

（記事ページなどにおいて）Lism設計では、基本的にコンテンツエリアのラッパー側で横幅をコントロールする**のではなく**、**コンテンツエリア直下のそれぞれの要素自身の幅を直接制御する**方式を推奨します。

例えば、ページ全体が次のような構造をしているとします。

```html {5}
<body>
	<header>ヘッダー</header>
	<main>
		<article>
			...コンテンツ...
		</article>
	</main>
	<footer>フッター</footer>
</body>
```

このとき、例えばコンテンツエリアの基本幅を`800px`にしたい時、主に次の①か②の選択肢があると思います。

```css
/* ① コンテンツのラッパー要素の幅を制御する*/
article{
	max-width: 800px;
}

/* ② コンテンツ自身（ラッパー要素の直下要素）の幅を制御する*/
article > * {
	max-width: 800px;
	margin-inline: auto;
}
```

Lism設計では、①ではなく②を前提としています。


<Note heading="なぜ?" preset="note" isFlow='s'>
コンテンツエリアの途中で**全幅コンテンツ**を作る場合の処理がシンプルになるためです。  
サイドバーありの2カラムレイアウトと、シンプルな1カラムレイアウトがサイト内に混在するケースでも対応しやすくなります。

また、**WordPressのブロックエディターの設計が②方式になっている**のも大きな理由です。
</Note>


①のケースを採用してしまうと、全幅コンテンツを作る場合のCSSが（汎用的な設計にしようとすると）複雑になってしまいます。

```css
.fullwide{
	width: 100vw;
	max-width: 100vw;
	left: calc(50% - 50vw);
}
```

みたいなCSSを書いた経験はないでしょうか。

これがベースになってしまうと、他のレイアウト条件なども考慮し始めるどんどん複雑になってしまうだけでなく、`vw`ではスクロールバーの幅を考慮できないという問題点もあります。

`@property`が使える環境では楽な解決方法があるので、Lismではそちらでの対応ができるようにもしています。
しかし、まだFirefoxでのサポート状況が怪しいため、無難に②方式を推奨します。


### コンテンツ制御クラスについて

上記の①に対応できるのが `.is--container`で、②に対応するのが `is--constrained`です。

ただし、`.is--container`単体ではサイズセットは行わず、containerエリアの宣言にも使えるようになっています。
コンテナ自体へのサイズセットを行うには、`.is--container:s` や `.is--container:m` を使います。

なので、Lismでは実際には次のようにHTMLを書くことになります。

```html
<article class="is--constrained">
	...コンテンツ...
</article>
```

<Demo>
	<Demo.Title>
		`.is--constrained` の挙動
	</Demo.Title>
	<Demo.Preview resize>
		<Container isFlow isConstrained bd="guide" style={{"--contentSize": "30rem"}}>
			<Box bd="guide">コンテンツ</Box>
			<Box bd="guide">コンテンツ</Box>
		</Container>
	</Demo.Preview>
	<Demo.Code>
		```jsx
		<Container isFlow isConstrained bd="guide" style={{"--contentSize": "30rem"}}>
			<Box bd="guide">コンテンツ</Box>
			<Box bd="guide">コンテンツ</Box>
		</Container>
		```
	</Demo.Code>
</Demo>

このデモエリアが小さいため、`--contentSize`でコンテンツ幅を小さめに上書きしています。


コンテナクエリの判定基準となる横幅が、`is--constrained`直下の要素ではラッパー要素の幅になることに注意が必要です。

### 幅広(.alignwide) と 全幅 (.alignfull) 

- `.alignwide` はmax-widthが大きめに変わるだけ、
- `.alignfull` はmax-width:100% (has--gutter直下のみネガティブマージンあり)

というシンプルな実装になります。

- alignwideは.is--constrainedの直下の時、サイズに合わせて変化する（1段階でかくなる）

<Demo>
	<Demo.Title>
		alignfull と alignwide
	</Demo.Title>
	<Demo.Preview resize>
		<Container isFlow isConstrained bd="guide" style={{ "--contentSize": "30rem", "--ls--contentSize--wide": "34rem" }}>
			<Box bd="guide">普通幅のコンテンツ</Box>
			<Box isFlow alignwide bd="guide">
				<p>幅広Box内のコンテンツ</p>
				<p>幅広Box内のコンテンツ</p>
			</Box>
			<Box isFlow alignfull bd="guide">
				<p>全幅コンテンツ</p>
			</Box>
		</Container>
	</Demo.Preview>
	<Demo.Code>
		```jsx
		<Container isFlow isConstrained bd="guide" style={{ "--contentSize": "30rem", "--ls--contentSize--wide": "34rem" }}>
			<Box bd="guide">普通幅のコンテンツ</Box>
			<Box isFlow alignwide bd="guide">
				<p>幅広Box内のコンテンツ</p>
				<p>幅広Box内のコンテンツ</p>
			</Box>
			<Box isFlow alignfull bd="guide">
				<p>全幅コンテンツ</p>
			</Box>
		</Container>
		```
	</Demo.Code>
</Demo>



### コンテンツの左右に余白をつける

`.is--constrained`で横幅を制御しただけでは、画面サイズが狭い場合に、コンテンツの左右に余白がなくなります（上のDemoエリアをリサイズしてみてください）。

そこで、コンテンツエリアの左右に余白をつけるための `.has--gutter` というクラスも別途用意しているので、併用して利用してください。


```html
<article class="is--constrained has--gutter">
	...コンテンツ...
</article>
```

<Demo>
	<Demo.Title>
		`.is--constrained&.has--gutter` の挙動
	</Demo.Title>
	<Demo.Preview resize>
		<Container
			isFlow
			isConstrained
			hasGutter
			bd='guide'
			style={{ "--contentSize": "30rem", "--ls--contentSize--wide": "34rem" }}
		>
			<Box bd="guide">コンテンツ</Box>
			<Box bd="guide">コンテンツ</Box>
		</Container>
	</Demo.Preview>
	<Demo.Code>
		```jsx
		...
		```
	</Demo.Code>
</Demo>

↓ なぜpaddingではなくわざわざ.has--gutterを使うか


### has--gutter 直下の alignfull について

コンテンツのラッパーに`.has--gutter`をつけてpaddingをつけるので、その内部の`.alignfull`を単純に`width:100%`にするだけではpaddingの内側までしか広がりません。

そこで、`.has--gutter > .alignfull` に関してのみ別途追加の調整を加え、**gutterサイズ分だけネガティブマージンで左右に広がる**ような実装になっています。


<Demo>
	<Demo.Title>
		`.is--constrained > .alignfull`の挙動
	</Demo.Title>
	<Demo.Preview resize>
		<Container
			isFlow
			isConstrained
			hasGutter
			bd='guide'
			style={{ "--contentSize": "30rem", "--ls--contentSize--wide": "34rem" }}
		>
			<Text bd='guide'>通常幅のコンテンツ</Text>
			<Box bd='guide' alignfull>ここは全幅 alignfull です</Box>
			<Box bd='guide' style={{ maxWidth: '100%' }}>max-width:100%だとこうなる</Box>
			<Text bd='guide'>通常幅のコンテンツ</Text>
		</Container>
	</Demo.Preview>
	<Demo.Code>
		```jsx
		...
		```
	</Demo.Code>
</Demo>


全幅用の`.alignfull` の幅調整が必要な特例はこの1点のみとなりますので、全体を通して非常にシンプルな実装になっています。  


{/* <Note heading='.is--constrained と .has--gutter を分ける理由' preset="note">
	`.is--constrained` に `.has--gutter`と同じ機能もつけて一つのクラスにまとめてしまえばもっとシンプルじゃないか、と思うかもしれません。
	多くの場合はそれで十分かもしれないですが、より柔軟なケースにも対応できるように、クラスを分けています。
</Note> */}


{/* ### DEMO
総合的に様々な組み合わせでコンテンツを並べてみます。 */}

{/* <Demo>
	<Demo.Title>
		このデモエリアをコンテンツエリアとして考えてください
	</Demo.Title>
	<Demo.Preview resize>
		<Container
			isFlow
			isConstrained
			hasGutter
			style={{ "--contentSize": "30rem", "--ls--contentSize--wide": "34rem" }}
		>
			<p>...普通のコンテンツ...</p>
			<p>▼ ただの全幅Box</p>
			<Box
				mbs="10"
				alignfull
				bgc='b200'
			>
				<p>全幅コンテンツ</p>
			</Box>

			<p>▼ 全幅Box</p>
			<Box
				mbs="10"
				alignfull
				bgc='b200'
			>
				<p>全幅コンテンツ</p>
			</Box>

			<p>▼ <code>isConstrained</code> な全幅Box</p>
			<Container
				mbs="10"
				alignfull
				bgc='b200'
				isConstrained
			>
				<p>全幅コンテンツ</p>
			</Container>

			<p>▼ <code>hasGutter</code> な全幅Box</p>
			<Container
				mbs="10"
				alignfull
				bgc='b200'
				hasGutter
			>
				<p>全幅コンテンツ</p>
			</Container>

			<p>▼ <code>isConstrained</code>,<code>hasGutter</code> な全幅Box</p>
			<Container
				alignfull
				bgc='b200'
				hasGutter
				isConstrained
			>
				<p>全幅コンテンツ</p>
			</Container>
			<p>...普通のコンテンツ...</p>
		</Container>
	</Demo.Preview>
	<Demo.Code>
		```jsx
		...
		```
	</Demo.Code>
</Demo> */}


## コンテンツ間の余白を制御するクラス( `.is--flow` ) [#is--flow]

Lismでは、**コンテンツ間の余白を管理するためのStateクラス**として、`.is--flow`を用意しています。  
`.is--flow`の直下では、コンテンツの間隔が `margin-block-start` で管理されます。


デフォルトの余白量 は `var(--s--40)` です。

<Demo>
	<Demo.Title>.is--flow</Demo.Title>
	<Demo.Preview resize p={30}>
		<div class="is--flow">
			<Text bd='guide'>コンテンツ</Text>
			<Text bd='guide'>コンテンツ</Text>
			<Text bd='guide'>コンテンツ</Text>
		</div>
	</Demo.Preview>
	<Demo.Code>
	```jsx
	<div class="is--flow">
		<p>コンテンツ</p>
		<p>コンテンツ</p>
		<p>コンテンツ</p>
	</div>
	```
	</Demo.Code>
</Demo>


### 余白量を変更する方法

`.is--flow`の子要素間の余白量を一括で変更するには、`--flowGap`を上書きするための`.-flowGap:`ユーティリティを使います。

flowGap用のトークンとして`s`,`m`,`l`があり、ユーティリティクラス（`.-flowGap:[s|m|l]`）も用意しています。

<Demo>
	<Demo.Title>flowGapの指定</Demo.Title>
	<Demo.Preview resize p={30}>
		<div class="is--flow -flowGap:s">
			<Text bd='guide'>コンテンツ</Text>
			<Text bd='guide'>コンテンツ</Text>
			<Text bd='guide'>コンテンツ</Text>
		</div>
	</Demo.Preview>
	<Demo.Code>
	```jsx
	<div class="is--flow -flowGap:s">
		<p>コンテンツ</p>
		<p>コンテンツ</p>
		<p>コンテンツ</p>
	</div>
	```
	</Demo.Code>
</Demo>

ユーティリティクラス以外の値をセットしたい場合は、変数と組み合わせます。

<Demo>
	<Demo.Title>任意の値をflowGapにセットする</Demo.Title>
	<Demo.Preview resize p={30}>
		<div class="is--flow -flowGap:" style={{"--flowGap": "1em"}}>
			<Text bd='guide'>コンテンツ</Text>
			<Text bd='guide'>コンテンツ</Text>
			<Text bd='guide'>コンテンツ</Text>
		</div>
	</Demo.Preview>
	<Demo.Code>
	```jsx
	<div class="is--flow" style="--flowGap:1em">
		<p>コンテンツ</p>
		<p>コンテンツ</p>
		<p>コンテンツ</p>
	</div>
	```
	</Demo.Code>
</Demo>


`.is--flow`直下での個別の余白調整には`mbs`ユーティリティが便利です。  
(mbsに対するユーティリティクラスをどれだけ用意するかは要検討)

<Demo className="has--box-guide">
	<Demo.Title>`mbs`での個別調整</Demo.Title>
	<Demo.Preview resize p={30}>
		<div class="is--flow">
			<p className='-bd:guide'>コンテンツ</p>
			<p className='-bd:guide'>コンテンツ</p>
			<p className="-bd:guide -mbs:10">`margin-block-start`に SPACE.10 指定</p>
		</div>
	</Demo.Preview>
	<Demo.Code>
	```jsx
	<div class="is--flow">
		<p>...</p>
		<p>...</p>
		<p class="-mbs:10">margin-block-start に SPACE.10 指定</p>
	</div>
	```
	</Demo.Code>
</Demo>


{/* <Alert preset="info">
	↑ `mbs={10}`によって、`.-mbs:10`クラスが出力されます。
</Alert> */}



### is--flow をネストする時の注意点

`flowGap`にカスタム値を指定した要素の直下で、さらに`is--flow`を配置すると、子要素側が自身の `--flowGap` に干渉してしまいます。

<Note preset='success' heading='次の位置でのネストは問題ありません'>
	- `flowGap`の指定がないシンプルな`.is--flow`の直下
	- `flowGap` がユーティリティクラス（ `-flowGap:[s~l]`）で指定されている`.is--flow`の直下
</Note>


<Demo>
	<Demo.Title>NG: `flowGap`を指定した直下で さらに`flowGap`を指定</Demo.Title>
	<Demo.Preview resize p={30}>
		<Box isFlow flowGap="8px">
			<p className='-bd:guide'>コンテンツ</p>
			<p className='-bd:guide'>コンテンツ</p>
			<Box isFlow flowGap="20px" bgc="pale">
				<p className='-bd:guide'>ネストされたコンテンツ</p>
				<p className='-bd:guide'>ネストされたコンテンツ</p>
			</Box>

			<Box isFlow bgc="pale">
				<p className='-bd:guide'>ネストされたコンテンツ</p>
				<p className='-bd:guide'>ネストされたコンテンツ</p>
				<Box isFlow='l' bgc="blue:20%">
					<p className='-bd:guide'>ネストされたコンテンツ</p>
					<p className='-bd:guide'>ネストされたコンテンツ</p>
					<Box isFlow='s' bgc="blue:20%">
						<p className='-bd:guide'>ネストされたコンテンツ</p>
						<p className='-bd:guide'>ネストされたコンテンツ</p>
					</Box>
				</Box>
			</Box>
			<p className='-bd:guide'>コンテンツ</p>
			<p className='-bd:guide'>コンテンツ</p>
		</Box>
	</Demo.Preview>
	<Demo.Code>
	```jsx {1,4}
	<Box isFlow flowGap="8px">
		<p>コンテンツ</p>
		<p>コンテンツ</p>
		<Box isFlow bgc="pale">
			<p>ネストされたコンテンツ</p>
			<p>ネストされたコンテンツ</p>
		</Box>
		<p>コンテンツ</p>
		<p>コンテンツ</p>
	</Box>
	```
	</Demo.Code>
</Demo>



<Demo>
	<Demo.Title>問題なし: シンプルな`isFlow`の直下にある`isFlow`への`flowGap`の指定</Demo.Title>
	<Demo.Preview resize p={30}>
		<Box isFlow>
			<p className='-bd:guide'>コンテンツ</p>
			<p className='-bd:guide'>コンテンツ</p>
			<Box isFlow={10} bgc="pale">
				<p className='-bd:guide'>ネストされたコンテンツ</p>
				<p className='-bd:guide'>ネストされたコンテンツ</p>
			</Box>
			<p className='-bd:guide'>コンテンツ</p>
			<Box isFlow='s' bgc="pale">
				<p className='-bd:guide'>ネストされたコンテンツ</p>
				<p className='-bd:guide'>ネストされたコンテンツ</p>
			</Box>
			<p className='-bd:guide'>コンテンツ</p>
		</Box>
	</Demo.Preview>
	<Demo.Code>
	```jsx {1,4,9}
	<Box isFlow>
		<p>コンテンツ</p>
		<p>コンテンツ</p>
		<Box isFlow={10} bgc="pale">
			<p>ネストされたコンテンツ</p>
			<p>ネストされたコンテンツ</p>
		</Box>
		<p>コンテンツ</p>
		<Box isFlow='s' bgc="pale">
			<p>ネストされたコンテンツ</p>
			<p>ネストされたコンテンツ</p>
		</Box>
		<p>コンテンツ</p>
	</Box>
	```
	</Demo.Code>
</Demo>


<Demo>
	<Demo.Title>問題なし: ユーティリティ`-flowGap:s`の直下で`isFlow`が入れ子になるケース</Demo.Title>
	<Demo.Preview resize p={30}>
		<Box isFlow="s">
			<p className='-bd:guide'>コンテンツ</p>
			<p className='-bd:guide'>コンテンツ</p>
			<Box isFlow bgc='pale'>
				<p className='-bd:guide'>ネストされたコンテンツ</p>
				<p className='-bd:guide'>ネストされたコンテンツ</p>
			</Box>
			<p className='-bd:guide'>コンテンツ</p>
			<Box isFlow={50} bgc='pale'>
				<p className='-bd:guide'>ネストされたコンテンツ</p>
				<p className='-bd:guide'>ネストされたコンテンツ</p>
			</Box>
			<p className='-bd:guide'>コンテンツ</p>
			<p className='-bd:guide'>コンテンツ</p>
		</Box>
	</Demo.Preview>
	<Demo.Code>
	```jsx {1,4,9}
	<Box isFlow="s">
		<p>コンテンツ</p>
		<p>コンテンツ</p>
		<Box isFlow>
			<p>ネストされたコンテンツ</p>
			<p>ネストされたコンテンツ</p>
		</Box>
		<p>コンテンツ</p>
		<Box isFlow={50}>
			<p>ネストされたコンテンツ</p>
			<p>ネストされたコンテンツ</p>
		</Box>
		<p>コンテンツ</p>
		<p>コンテンツ</p>
	</Box>
	```
	</Demo.Code>
</Demo>

