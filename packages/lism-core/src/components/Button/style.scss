:root {
	// fill時のカラーをグローバルに定義？ → .-c:white なエリアでは #000 に反転させたりしておくと便利か。
	// → .-c:white を用意する意味もでてくる。
	// --lism--c--filled: #fff;
}

@layer lism-module {
	// --btn--color:
	.l--button {
		--keycolor: var(--b900);
		--c: inherit;
		--bdc: transparent;
		--bgc: transparent;
		--icon--scale: 1.25; // offsetとバランス合わせる
		--icon--offset: 0%; //25%;
	}

	.l--button[data-variant='fill'] {
		--bgc: var(--keycolor);
		--bdc: var(--bgc); // reverse用
		--c: var(--c--filled); // filledColor?
		--rev--bgc: transparent;
	}

	.l--button[data-variant='outline'] {
		--bdc: var(--keycolor);
		--c: var(--bdc); // bdc上書きするだけで --c も変わるように

		// reverse用
		--rev--c: var(--hov--c, var(--c--filled));
		// --rev--bgc: var(--bdc);
	}

	.l--button[data-variant='ghost'] {
		--c: var(--keycolor);
		--rev--c: var(--hov--c, var(--c--filled)); // reverse用
	}
}

// pYは小さめにして、minHで最低限の高さを確保.
:where(.l--button) {
	display: flex;
	justify-content: center;
	align-items: center;
	text-decoration: none;
	width: fit-content;
	color: var(--c);
	background-color: var(--bgc);
	border: solid 1px var(--bdc); // アウトラインと並べたときにサイズに差がでないように
	border-radius: var(--radius--1);
	line-height: 1.25;
	padding-block: 0.325em;
	padding-inline: 1em;
	min-block-size: 3em;
	gap: 0.5em; // --gap--icon ?
	// min-width: 2em;
}

// .l--button[data-variant='fill'] {
// }

// .l--button[data-variant='outline'] {
// }

// .l--button[data-variant='ghost'] {
// 	// color: var(--keycolor);
// 	--rev--c: var(--hov--c, #fff); // reverse用
// }

// .l--button.l--grid,
.l--button.l--grid {
	// display: grid;
	--gta--val: 'left center right';
	--gtc--val: 1em 1fr 1em;
}
.l--grid > .l--button__text {
	justify-self: center;
	grid-area: center;
}

// .l--button[data-icon-offset="0"]{
// 	--icon--offset: 0;
// }

.l--button__icon {
	scale: var(--icon--scale);
	flex-shrink: 0;

	&[data-position='left'] {
		grid-area: left;
		translate: calc(0px - var(--icon--offset));
	}
	&[data-position='right'] {
		grid-area: right;
		translate: var(--icon--offset);
	}
}
