// Houdini カスタムプロパティ
.-container\:s {
	container-type: size;
}
.-container\:i {
	container-type: inline-size;
}
// .has-global-padding はコア以外の要素で使うと想像した結果にならないことがあるので同じようなことをするクラスを作る
.has--gutter {
	padding-inline: var(--gutter);
}

// 内部のコンテンツ幅を制御する。
:is(.is--constrained, [class*='is--constrained:']) {
	container-type: inline-size;
	> * {
		max-inline-size: min(100%, var(--contentSize));
		margin-inline: auto;
	}

	// 左寄せ・右寄せ?
	// > :where(.alignleft, .alignright)
}

// それぞれの直下要素( > * ) に対してスタイルをセットした方が、ネスト時の影響をなくせるが、constrainedのネストが多様されることは少ないと思うので、一旦親側の変数管理のみで実装。
.is--constrained {
	--contentSize: var(--size--m);
	--size--wide: var(--size--l);
}
.is--constrained\:s {
	--contentSize: var(--size--s);
	--size--wide: var(--size--m);
}
.is--constrained\:l {
	--contentSize: var(--size--l);
	--size--wide: 100%;
}
// .is--constrained\:

// is--container かつ is--constrained を考慮するか？

// コンテナクエリの基点とする要素。
// コンテンツ幅を自身の幅にセットして制御したい時にも使う。（そのままでは幅のセットはしない）
// （実際のサイズセットは w や h を指定してもらう。 w でも maxW でもいいように、標準で max-inline:100% にしている）
.is--container {
	container-type: inline-size;
	margin-inline: auto;
	max-inline-size: 100%;
}

// .is--container {--containerSize: var(--size--m);}
// .is--container\: {max-inline-size: var(--containerSize);}
// .is--container\:s {max-inline-size: var(--size--s);}
// .is--container\:m {max-inline-size: var(--size--s);}
// .is--container\:l {max-inline-size: var(--size--l);}

// これは → .is--container.alignfull でできる
// .is--container\:full {max-inline-size: 100%;}

// flowより強く、ユーティリティより弱く。
:where(.alignfull) + .alignfull {
	margin-block-start: 0;
}

.alignfull {
	container-type: inline-size;
	max-inline-size: 100%;

	:where(.has--gutter) > & {
		// --contentSize 変数は min()で100%と比較してるので、直接セット
		max-inline-size: calc(100% + var(--gutter) * 2);
		margin-inline: calc(var(--gutter) * -1);
	}
}

.alignwide {
	container-type: inline-size;
	max-inline-size: var(--size--wide, 100%);
}

// .has--gutter\:s {
// 	padding-inline: var(--gutter--s);
// }

// @property が使える環境であればコンテナのさらに親要素の幅を参照できるので、containerを1段階飛び出せる。
// ↓ @property の疑似サポートチェック
//   - @propety : chirome(85~),edge(85~),opera(71~),Samsung(14~)
//   - content-visibility : chirome(85~),edge(85~),opera(71~), safari:x,firefox:x, Samsung(14~)
//   - <length> lh : Safari(16.4~), Firefox(120~121 ?), Chrome,Edge(109~), Opera(95~), Samsung(21~)
// ↓
// @supports (content-visibility: auto) or (top: 0lh)
@supports (content-visibility: auto) or (top: 0lh) {
	// cqw を算出値で保持するために登録済みカスタムプロパティとして定義
	@property --size--100cqw {
		syntax: '<length-percentage>';
		initial-value: 100%;
		inherits: true;
	}
	@property --size--screenW {
		syntax: '<length>';
		initial-value: 100vw;
		inherits: true;
	}

	// :is(.is--constrained, [class*='is--constrained:']) {
	// 	--size--100cqw: 100%;
	// }

	.is--container {
		--size--100cqw: 100cqw; // この時点でのcqwをセット

		> .alignfull {
			max-inline-size: var(--size--100cqw);
			margin-inline: calc(50% - var(--size--100cqw) / 2);
		}
	}

	// .is--extend\:screen,
	.alignscreen {
		max-inline-size: var(--size--screenW);
		margin-inline: calc(50% - var(--size--screenW) / 2);
	}
}
